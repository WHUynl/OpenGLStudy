# 1.深度测试

深度缓冲就像**颜色缓冲(Color Buffer)**（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。<font color=red>深度缓冲是由窗口系统自动创建的</font>，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。

当深度测试(Depth Testing)被启用的时候，**OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。**如果深度测试失败了，片段将会被丢弃。

屏幕空间坐标与通过OpenGL的**glViewport**所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。**gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。**z值就是需要与深度缓冲内容所对比的那个值。

```c++
//开启深度测试
glEnable(GL_DEPTH_TEST);
/*如果启用了深度缓冲，应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：*/
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为GL_FALSE就可以了：
glDepthMask(GL_FALSE);

```

## 2.深度测试函数

OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用<font color=red>glDepthFunc</font>函数来设置比较运算符（或者说深度函数(Depth Function)）：

```c++
//参数设置，以及意义见下表
glDepthFunc(GL_LESS);
```

![image-20210421220529260](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210421220529260.png)

## 3.深度冲突

一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做**深度冲突(Z-fighting)**，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。原因：**这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。**

![image-20210421221155374](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210421221155374.png)

### 4.防止深度冲突

方法：

**1.永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠**。

**2.尽可能将近平面设置远一些**			

**3.牺牲一些性能，使用更高精度的深度缓冲**